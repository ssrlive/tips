

## 將 log 庫的日志輸出到 Windows 的窗口内

```rust
/*
[dependencies]
log = { version = "0.4", features = ["std", "serde"] }

[dependencies.windows]
version = "0.48"
features = [
    "Data_Xml_Dom",
    "Win32_Foundation",
    "Win32_Security",
    "Win32_System_Threading",
    "Win32_UI_WindowsAndMessaging",
    "Win32_UI_Controls",
]
 */

use std::ffi::CString;
use windows::{
    core::*, Win32::Foundation::*, Win32::UI::Controls::*, Win32::UI::WindowsAndMessaging::*,
};

fn log_to_window(msg: &str) {
    unsafe {
        let hwnd = FindWindowA(s!("RichEdit20W"), None);
        if hwnd != HWND(0) {
            let len = SendMessageA(hwnd, EM_GETLINECOUNT, WPARAM::default(), LPARAM::default());
            SendMessageA(
                hwnd,
                EM_SETSEL,
                WPARAM(len.0 as usize),
                LPARAM(len.0 as isize),
            );
            let c_msg = CString::new(msg).unwrap();
            let ptr = c_msg.as_bytes_with_nul().as_ptr();
            SendMessageA(hwnd, EM_REPLACESEL, WPARAM::default(), LPARAM(ptr as isize));
        } else {
            println!("{}", msg);
        }
    }
}

struct WindowLogger;

impl log::Log for WindowLogger {
    fn enabled(&self, metadata: &log::Metadata) -> bool {
        metadata.level() <= log::Level::Debug
    }

    fn log(&self, record: &log::Record) {
        if self.enabled(record.metadata()) {
            log_to_window(&format!("{} - {}\n", record.level(), record.args()));
        }
    }

    fn flush(&self) {}
}

fn main() {
    log::set_boxed_logger(Box::new(WindowLogger)).unwrap();
    log::set_max_level(log::LevelFilter::Debug);

    log::debug!("This is a debug message");
    log::info!("This is an info message");
    log::warn!("This is a warning message");
    log::error!("This is an error message");
}

```

## 將 serde::Serialize 這個 trait 的實例塞進容器中

這個例子涉及多個難點,
- 使用 `AsAny` 庫幫助 trait object 向下轉型.
- 使用 `Rc` 來實現 trait object 的共享.
- 使用 `serde` 來實現物件序列化.
  > 由於 `serde::Serialize` 這個 trait 帶有泛型參數, 所以它的實例不允許轉型成 trait object,
  > 於是使用了 `erased_serde` 庫來擦除泛型參數, 讓它能存儲到容器中. 這非常高深莫測, 但是很有用.

https://gist.github.com/ssrlive/f515fac13a08b860b9b59a3071e17013

這個例子有個非常詭異的地方: 它必須依賴 `rustfmt` 這個庫才能編譯, 否則報錯如下, 非常奇怪. 
但加上它以後, 搜索 `Cargo.lock` 文件, 會發現 `serde` 並沒有依賴 `rustfmt`, 那麼為什麼缺了它就編譯失敗呢? 百思不得騎姐.

```
error[E0277]: the trait bound `Rc<dyn Node>: _::_serde::Serialize` is not satisfied
    --> src\main.rs:10:33
     |
10   | #[derive(Clone, Debug, Default, serde::Serialize)]
     |                                 ^^^^^^^^^^^^^^^^ the trait `_::_serde::Serialize` is not implemented for `Rc<dyn Node>`
...
13   |     children: Vec<std::rc::Rc<dyn Node>>,
     |     -------- required by a bound introduced by this call
     |
     = help: the following other types implement trait `_::_serde::Serialize`:
               &'a T
               &'a mut T
               ()
               (T0, T1)
               (T0, T1, T2)
               (T0, T1, T2, T3)
               (T0, T1, T2, T3, T4)
               (T0, T1, T2, T3, T4, T5)
             and 142 others
     = note: required for `Vec<Rc<dyn Node>>` to implement `_::_serde::Serialize`
note: required by a bound in `_::_serde::ser::SerializeStruct::serialize_field`
    --> C:\Users\...\serde-1.0.164\src\ser\mod.rs:1901:12
     |
1901 |         T: Serialize;
     |            ^^^^^^^^^ required by this bound in `SerializeStruct::serialize_field`
```

## rust 的類型體操, 太刺激了.

https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=8098867927003a237c40f984f30159fb

你看那一句你看懂了嗎?
```rust
        if let Some(obj) = <dyn MyTrait>::as_any(&**item).downcast_ref::<MyStruct1>() {
            obj.mmmm();
        }
```

## 让 rust 支持 armv7-apple-ios 目标

我有一台 旧 苹果 设备, 跑着 `iOS 9`, 我想让我的 `rust` 代码跑在我的旧苹果设备上,
但是 `rustup` 上已经不提供 `armv7-apple-ios` 了, 我们能怎么做?
```
rustup toolchain install nightly
rustup component add rust-src --toolchain nightly

cargo new --lib foo
cd foo
cargo +nightly build -Z build-std --target armv7-apple-ios

lipo -info target/armv7-apple-ios/debug/libfoo.a
  Non-fat file: target/armv7-apple-ios/debug/libfoo.a is architecture: armv7
```

## Use Rust in iOS Apps

https://github.com/thombles/dw2019rust


## 在 Rust 中的 SocketAddr 的 默认构造函数

```rust
let addr = "127.0.0.1:8080".parse::<std::net::SocketAddr>().unwrap();
let addr = std::net::SocketAddr::from((std::net::Ipv4Addr::LOCALHOST, 0));
```

## 讓 VSCode 解析 Rust 代碼時針對的目標平臺是 Android

![image](https://user-images.githubusercontent.com/30760636/237045619-24086d9b-eb03-4c01-916a-9975524d3fb0.png)


## Rust 与 Java 交互 - JNI 模块编写 - 实践总结

https://rustcc.cn/article?id=4ca84a67-d972-4460-912e-a297ec5edc0a

https://zhuanlan.zhihu.com/p/568062165


## 在 Rust 中使用 Yew 框架實現用戶登錄認證

參考以下資源：

一個詳細的教程，介紹了如何使用 `JWT（JSON Web Token）` 在 `Rust` 和 `Yew.rs` 中構建一個包含用戶註冊、登錄、登出和頁面權限控制的單頁應用。

https://codevoweb.com/frontend-app-with-rust-and-yew-user-signup-and-login/


一篇文章，解釋了 `JWT` 的原理和優勢，並展示了如何在 `Rust` 的 `Actix Web` 框架中實現 `JWT` 認證。

https://blog.logrocket.com/jwt-authentication-in-rust/


一個 `crate`，提供了一些組件和函數，可以幫助您在 `Yew` 中使用 `OAuth2` 協議進行認證。

https://docs.rs/yew-oauth2/latest/yew_oauth2/components/use_authentication/


## Rust reqwest: how to wait until the page is fully loaded?

https://stackoverflow.com/questions/72082257/rust-reqwest-how-to-wait-until-the-page-is-fully-loaded

Reqwest does not do this, it only loads the data at a given URL and nothing more.
What you ask for is what a browser displays when loading a webpage which will include loading other assets, embedding pages, running scripts, etc.

You need a full-on browser to get this functionality, which will require a web-driver (like selenium).
Just looking around for Rust solutions, maybe [fantoccini](https://crates.io/crates/fantoccini) or [chromiumoxide](https://crates.io/crates/chromiumoxide) or [headless_chrome](https://crates.io/crates/headless_chrome) catch your fancy.


## Rust 定义 log 的级别 Level

- Error: 严重错误
- Warn: 危险状况
- Info: 有用的信息
- Debug: 低优先级的调试信息
- Trace: 非常低的优先级，很详细的信息

一般生产系统我们会把级别设置为 `Info` 或者 `Warn` 级别, 在开发的过程中才设置为 `Debug` 甚至 `Trace` 级别。

https://colobu.com/2019/09/22/rust-lib-per-week-log/


## Rust 错误处理库

- 【Rust每周一库】failure - 错误处理库 
   https://blog.51cto.com/u_15127605/2763290

- 【Rust每周一库】 anyhow 和 thiserror - 错误处理库
   https://blog.51cto.com/u_15683898/5426842


## Rust 错误处理推荐使用什么库？

目前一般认为对于应用程序推荐使用 `anyhow`，而对于库推荐使用 `thiserror`。

`anyhow` 提供了一个基于特质对象的错误类型，可以很容易地将不同来源的错误统一到单一来源，并可以方便地为错误添加上下文，以及就地创建新的错误。

`thiserror` 则提供了一个 `derive` 宏，方便为自定义的错误类型实现 `Error` 特质。


## Rust 優雅錯誤處理

https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=cfd02ae7126fac48d00e07fab2f976c1


## Rust 的 @ 的用法

https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=54623f03a27d822b86a4bb9504753f19


## Rust 避免所有權轉移

https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=0587765609e44d9a26b2497285be0ad3


## Rust 的多態

https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=d6225fb6174cb83a991defd1f4d199fa
